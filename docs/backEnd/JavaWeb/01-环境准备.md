# 环境准备

## 初始化数据库

创建数据库

```sql
create database javaweb;
```

创建表

```sql
-- ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
-- 存储引擎设置为 InnoDB，支持 事务 (Transaction)，保证数据安全性（如转账操作要么全部成功，要么全部失败）。支持 行级锁，并发性能好。支持 外键约束，表与表之间可以建立外键关系。
-- utf8mb4 是 MySQL 里真正的 完整 UTF-8 实现，支持所有 Unicode 字符

CREATE TABLE goods (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '唯一ID',
    fname VARCHAR(100) NOT NULL COMMENT '名字',
    price DECIMAL(10,2) NOT NULL COMMENT '价格',
    fcount INT NOT NULL COMMENT '库存数量',
    remark VARCHAR(255) COMMENT '描述'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

```

插入数据

```sql
INSERT INTO goods (fname, price, fcont, remark) VALUES
('苹果', 3.50, 100, '新鲜的红富士苹果'),
('梨', 2.80, 80, '香甜多汁的雪梨'),
('桃子', 5.20, 60, '水蜜桃，入口即化'),
('香蕉', 4.00, 120, '进口香蕉，口感香甜'),
('橙子', 3.80, 90, '维C丰富的橙子'),
('西瓜', 15.00, 30, '大西瓜，清凉解暑');
```

## 数据库连接池

**druid使用步骤：**

方式1：手动导jar包

```ts
1 把druid-1.1.10.jar包放在libs文件夹中
2 选中libs文件夹 右键 add as library
3 选择要使用的范围
4 这样就可以下拉查看里边的class文件了
```

方式2：使用maven管理，在pom.xml上添加

```xml
以后再使用
```

新建jdbc.properties，位于` src/jdbc.properties`

```java
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/yourdb?useSSL=false&serverTimezone=UTC&characterEncoding=utf8
username=root
password=123456

# 连接池参数
initialSize=5
maxActive=20
minIdle=5
maxWait=60000

```

修改 `DBUtil.java`，使用 Druid，位于 src/com.fruit.utils.DButil.java

```java
package com.example.project.utils;

import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Properties;

public class DBUtil {

    private static DataSource dataSource;

    // 初始化连接池
    static {
        try {
            Properties prop = new Properties();
            InputStream in = DBUtil.class.getClassLoader().getResourceAsStream("jdbc.properties");
            prop.load(in);
            dataSource = DruidDataSourceFactory.createDataSource(prop);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // 获取连接
    public static Connection getConnection() throws Exception {
        return dataSource.getConnection();
    }

    // 关闭资源
    public static void close(Connection conn, Statement stmt, ResultSet rs) {
        try {
            if (rs != null) rs.close();
            if (stmt != null) stmt.close();
            if (conn != null) conn.close(); // 归还连接到连接池
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

测试类

```java
package com.example.project.test;

import com.example.project.utils.DBUtil;

import java.sql.Connection;

public class TestDB {
    public static void main(String[] args) throws Exception {
        Connection conn = DBUtil.getConnection();
        System.out.println("获取连接成功: " + conn);
        conn.close(); // 归还到池
    }
}

```

## API

### DataSource接口

`DataSource` 是 **JDBC 规范接口**，它是 `DriverManager` 的替代方案，用于获取数据库连接。

```java
// 简单理解：DataSource 提供数据库连接
DataSource ds = ...;
Connection conn = ds.getConnection();
```

方法

getConnection()

```java
作用：获取数据库连接
    
参数：无
    
返回值：Connection对象
    
示例：
    
Connection getConnection() throws SQLException; // 获取数据库连接
```

```java
public interface DataSource {
    Connection getConnection() throws SQLException; // 获取数据库连接
    Connection getConnection(String username, String password) throws SQLException; // 指定用户名密码
    PrintWriter getLogWriter() throws SQLException; // 获取日志输出
    void setLogWriter(PrintWriter out) throws SQLException; // 设置日志输出
    void setLoginTimeout(int seconds) throws SQLException; // 设置超时时间
    int getLoginTimeout() throws SQLException; // 获取超时时间
    java.util.logging.Logger getParentLogger() throws SQLFeatureNotSupportedException; // 日志
}
```

### DruidDataSource接口

构造方法

```java
// 无参构造
public DruidDataSource()

// 有参构造（常见写法是先 new 再 set，不太用到有参构造）
public DruidDataSource(boolean lockFair) 
// lockFair: 公平锁标志，一般默认 false 即可
    

```

方法

```java
作用：
    
参数：
    
返回值：
    
示例：
```

```ts
// 基础配置
setDriverClassName(String driverClassName)   // 设置 JDBC 驱动类
setUrl(String url)                           // 设置数据库连接 URL
setUsername(String username)                 // 设置数据库用户名
setPassword(String password)                 // 设置数据库密码

// 连接池管理
setInitialSize(int size)     // 设置初始化时创建的连接数
setMaxActive(int maxActive)  // 设置最大连接数
setMinIdle(int minIdle)      // 设置最小空闲连接数
setMaxWait(long millis)      // 获取连接时最大等待时间（毫秒）

// 超时与检测
setValidationQuery(String sql)   // 用来检测连接是否有效的 SQL，如 "SELECT 1"
setTestOnBorrow(boolean flag)    // 从连接池取连接时，是否检测有效性
setTestOnReturn(boolean flag)    // 还回连接时，是否检测有效性
setTestWhileIdle(boolean flag)   // 空闲时是否检测有效性
setTimeBetweenEvictionRunsMillis(long millis) // 检测线程运行间隔
setMinEvictableIdleTimeMillis(long millis)    // 连接保持空闲而不被驱逐的最小时间

// 获取连接
Connection getConnection()  
Connection getConnection(String username, String password)  

// 关闭
close()    // 关闭数据源，释放资源
```



### DruidDataSourceFactory工厂类

**`DruidDataSourceFactory`** 并不是接口，而是阿里 Druid 提供的一个 **工厂类**，用于通过配置（`Properties`）快速创建 `DruidDataSource` 对象。

构造方法

```ts
// 私有构造（工具类，不允许实例化）
private DruidDataSourceFactory()
// 所以你不能 new DruidDataSourceFactory()，只能直接调用它的 静态方法
	
```

常用方法

createDataSource(Properties properties)

```java
作用：
    根据传入的配置（Properties 对象），创建并返回一个 DruidDataSource 数据源。

参数：
    properties —— 数据源配置信息，常见 key 包括：
        driverClassName   数据库驱动类
        url               数据库连接地址
        username          用户名
        password          密码
        initialSize       初始化连接数
        maxActive         最大连接数
        minIdle           最小空闲连接数
        maxWait           最大等待时间
        validationQuery   用于检测连接是否可用的 SQL

返回值：
    DataSource —— 返回一个配置好的 DruidDataSource 对象

示例：
Properties props = new Properties();
props.setProperty("driverClassName", "com.mysql.cj.jdbc.Driver");
props.setProperty("url", "jdbc:mysql://localhost:3306/test");
props.setProperty("username", "root");
props.setProperty("password", "123456");

DataSource ds = DruidDataSourceFactory.createDataSource(props);
Connection conn = ds.getConnection();
System.out.println("连接成功：" + conn);
conn.close();
```



## 项目分层

在 Java 项目里经常看到一个叫 **`pojo`** 的文件夹，它不是 Java 官方规定的，而是大家约定俗成的一种目录名。

**pojo的含义**

- **POJO** = **Plain Old Java Object**，翻译为“简单的 Java 对象”。
- 特点：
  - 只有属性（字段）和对应的 **getter/setter** 方法；
  - 可能会有构造方法、`toString()`、`equals()`、`hashCode()`；
  - **没有业务逻辑**，不继承框架类，也不实现复杂接口。

比如你有一个 `goods` 表，可能会在 `pojo` 里放一个 `Goods.java`。

```java
package com.example.project.pojo;

public class Goods {
    private int id;
    private String fname;
    private double price;
    private int fcont;
    private String remark;

    // getter 和 setter
    // toString()
}

```

**常见的分层**

```java
src/main/java/com/example/project/
├── controller   （控制层，处理请求）
├── service      （业务逻辑层）
├── dao          （数据访问层）
├── pojo / entity（实体类/数据对象）
```

**简单项目举例**

项目结构

```java
src/main/java/com/example/project/
├── controller
│   ├── GoodsListServlet.java
│   └── GoodsAddServlet.java
├── service
│   └── GoodsService.java
├── dao
│   └── GoodsDao.java
├── pojo
│   └── Goods.java
└── utils
    └── DBUtil.java
```

## JDBC复习

在根目录创建libs文件夹，导入 druid 和 mysql 驱动包。把libs作为 Add as Library

创建dao目录（src/dao），pojo目录(src/pojo)，utils目录(src/utils)，test目录(test/)。

创建 数据库配置文件 jdbc.properties (src/jdbc.properties)。

封装mysql数据库中表的实体类：src/pojo/Fruit.java

```java
package com.fruit.pojo;

import java.math.BigDecimal;

public class Fruit {
    // 私有属性
    private Integer id;
    private String fname;
    private BigDecimal price; // 用 BigDecimal 存金额
    private Integer fcount;
    private String remark;

    public Fruit() {
    }

    public Fruit(Integer id, String fname, BigDecimal price, Integer fcount, String remark) {
        this.id = id;
        this.fname = fname;
        this.price = price;
        this.fcount = fcount;
        this.remark = remark;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getFname() {
        return fname;
    }

    public void setFname(String fname) {
        this.fname = fname;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    public Integer getFcount() {
        return fcount;
    }

    public void setFcount(Integer fcount) {
        this.fcount = fcount;
    }

    public String getRemark() {
        return remark;
    }

    public void setRemark(String remark) {
        this.remark = remark;
    }

    @Override
    public String toString() {
        return "Fruit{" +
                "id=" + id +
                ", fname='" + fname + '\'' +
                ", price=" + price +
                ", fcount=" + fcount +
                ", remark='" + remark + '\'' +
                '}';
    }
}

```

封装数据库连接池工具类：src/utils/DButil.java

```java
package com.fruit.utils;

import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.pool.DruidPooledConnection;

import java.io.InputStream;
import java.sql.*;
import java.util.Properties;

public class DButil {
    // 定义静态数据
    private static String DRIVER;
    private static String URL;
    private static String USER;
    private static String PWD;
    // 定义静态的 数据库连接池对象
    private static DruidDataSource dataSource;

    // 静态代码块，在类加载时读取配置
    static {
        try {
            // 创建Properties Map集合类
            Properties prop = new Properties();
            // 获取当前类加载器，获取 jdbc的读取流
            InputStream in = DButil.class.getClassLoader().getResourceAsStream("jdbc.properties");
            // 加载配置文件
            prop.load(in);

            // 获取数据库连接池对象(方式1)
            // 方式 1：DruidDataSourceFactory.createDataSource(prop)
            // 直接用 工厂方法 根据 Properties 配置生成一个 DruidDataSource 对象
            // 配置集中在 jdbc.properties 文件里，支持 Druid 的各种高级配置
            // dataSource = DruidDataSourceFactory.createDataSource(prop);

            // 创建数据库连接池对象(方式2)
            // 手动创建 Druid 连接池对象，然后逐个设置属性
            dataSource = new DruidDataSource();

            // 获取properties文件中的值
            DRIVER = prop.getProperty("DRIVER");
            URL = prop.getProperty("URL");
            USER = prop.getProperty("USER");
            PWD = prop.getProperty("PWD");

            // 加载mysql驱动(数据库连接池 Druid会自动加载mysql驱动)
            // Class.forName(DRIVER);

            // 设置用户名，密码
            dataSource.setDriverClassName(DRIVER);
            dataSource.setUrl(URL);
            dataSource.setUsername(USER);
            dataSource.setPassword(PWD);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // 获取连接,返回一个连接对象
    public static Connection getConnection() {
        try {
           return dataSource.getConnection();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    // 关闭连接
    public static void close(Connection conn, Statement stmt, ResultSet rs) {
        try {
            if (rs != null) rs.close();
            if (stmt != null) stmt.close();
            if (conn != null) conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

封装反射的工具类 ClassUtil.java (src/utils/ClassUtil)

```java
package com.fruit.utils;

import java.lang.reflect.Field;

public class ClassUtil {
    // 获取 Class对象
    public static Class getEntityClass(String entityName){
        try {
            return Class.forName(entityName);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }
    // 通过反射创建Class对象的实例
    public static Object createInstance(String entityName){
        try {
            return getEntityClass(entityName).newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        return null;
    }

    // 通过反射给实例的属性赋值
    public static void setProperty(Object obj,String propertyName,Object propertyValue){
        try {
            Field field = obj.getClass().getDeclaredField(propertyName);
            // 忽略警告
            field.setAccessible(true);
            // 赋值
            field.set(obj,propertyValue);
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
}

```

封装通用 BaseDao (src/dao/BaseDao.java)

```java
package com.fruit.dao;

import com.fruit.utils.ClassUtil;
import com.fruit.utils.DButil;

import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

// 定义BaseDao为一个抽象类
public abstract class BaseDao<T> {
    // 定义泛型的名称
    private String entityClassName;
    // 定义ResultSet结果集
    private ResultSet rs;
    // 连接池对象
    Connection connection = null;
    // sql语句对象
    PreparedStatement pstm = null;

    // 在无参构造中，获取泛型类型，子类调用构造，默认调用父类的无参构造
    public BaseDao(){
        // 调用
        getEntityClassName();

    }
    // 获取子类实例给父类泛型T传入的名称
    private void getEntityClassName(){
        // 通过子类实例对象，获取父类（自己）的泛型T的实际名称
        // 此处的this代表的是FruitDaoImpl实例，而不是BaseDao
        // this.getClass()得到的就是FruitDaoImpl的Class对象
        // getGenericSuperclass() 获取带有泛型的父类,因此可以获取到 BaseDao<Fruit>
        // 因为我们是这样定义的：class FruitDaoImpl extends BaseDao<Fruit>，所以泛型父类是： BaseDao<Fruit>
        Type genericSuperclass = this.getClass().getGenericSuperclass();
        // 把父类的泛型信息，从通用的 Type 强转为 ParameterizedType，以便后续获取实际的泛型参数。
        // 强转为ParameterizedType类型
        ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;
        // getActualTypeArguments 获取实际的类型参数
        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
        // 因为当前BaseDao<T>后面只有一个泛型位置，所以此处我们使用的是[0]
        // getTypeName() 获取类型名称
        // getTypeName() 返回完整类名，例如 "com.xxx.pojo.Fruit"
        String typeName = actualTypeArguments[0].getTypeName();
        entityClassName = typeName;
    }

    // 定义设置参数的方法
    private void setParams(PreparedStatement psmt , Object... params) throws SQLException {
        if(params!=null && params.length>0){
            for (int i = 0; i < params.length; i++) {
                psmt.setObject(i+1,params[i]);
            }
        }
    }

    // 执行增删改的操作
    protected int executeUpdate(String sql,Object ...params){
        // 去除空格，并转为小写
        sql = sql.trim().toUpperCase();
        // 设置标记是否是插入语句
        boolean insertFlag = sql.startsWith("INSERT INTO");
        // 获取连接对象
        connection = DButil.getConnection();

        try {
            // 判断是否是插入语句
            if (insertFlag){
                // 获取sql执行语句对象,插入语句
                pstm = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            }else{ // 非插入语句
                pstm = connection.prepareStatement(sql);
            }
            // 给sql语句传入参数
            setParams(pstm,params);
            // 执行sql
            int resRow = pstm.executeUpdate();
            // 返回
            if(insertFlag) { // 如果是插入语句
                // 获取自增id
                rs = pstm.getGeneratedKeys();
                // 如果返回有值
                if(rs.next()){
                    // 获取第一列数据
                    return (rs.getInt(1));
                }
            }else{
                return resRow; // 返回默认受影响行数
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            // 关闭连接
            DButil.close(connection,pstm,rs);
        }
        return 0;
    }

    // 查询的方法
    protected List<T> executeQuery(String sql,Object ...params){
        List<T> list = new ArrayList<>();
        connection = DButil.getConnection();
        try {
            // 获取statement对象
             pstm = connection.prepareStatement(sql);
             // 设置SQL参数
            setParams(pstm,params);
            // 执行SQL
            rs = pstm.executeQuery();
            // 方式1：通过反射来处理
            // 方式2：通过数据解析器来处理（见JDBC章节）
            // 获取结果集的元数据，也就是每一行的数据
            ResultSetMetaData metaData = rs.getMetaData();
            // 获取元数据的列数
            int columnCount = metaData.getColumnCount();
            // 遍历结果集
            while(rs.next()){
                // 通过反射获取实体类的Class对象
                Class entityClass = ClassUtil.getEntityClass(entityClassName);
                // 通过反射创建实例,强转为T类型
                T instance = (T)ClassUtil.createInstance(entityClassName);
                // 遍历
                for (int i = 0; i < columnCount; i++) {
                    // 读取列名
                    String columnName = metaData.getColumnName(i + 1);
                    // 获取当前行指定列的值
                    Object columnValue = rs.getObject(i + 1);
                    // 给实例赋值
                    ClassUtil.setProperty(instance,columnName,columnValue);
                }
                // 集合中添加元素
                list.add(instance);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            DButil.close(connection,pstm,rs);
        }
        return list;
    }
}

```

定义具体类的DAO接口：src/dao/FruitDao.java

```java
package com.fruit.dao;

import com.fruit.pojo.Fruit;

import java.util.List;

public interface FruitDao {
    // 获取所有的库存记录
    List<Fruit> getFruitList();

    // 添加新库存
    void addFruit(Fruit fruit);

    // 删除指定的库存记录
    void delFruit(Integer id);

    // 获取指定的库存记录
    Fruit getFruit(Integer id);
    Fruit getFruit(String name);

    // 修改库存记录
    void updateFruit(Fruit fruit);
}

```

定义实体类DAO接口的实现类 src/dao/impl/FruitDaoImpl.java

```java
package com.fruit.dao.impl;

import com.fruit.dao.BaseDao;
import com.fruit.dao.FruitDao;
import com.fruit.pojo.Fruit;

import java.util.List;

public class FruitDaoImpl extends BaseDao<Fruit> implements FruitDao {
    @Override
    public List<Fruit> getFruitList() {
        String sql = "select * from goods";
        List<Fruit> fruits = this.executeQuery(sql, null);
        return fruits;
    }

    @Override
    public void addFruit(Fruit fruit) {
        String sql = "insert into goods values(0,?,?,?,?)";
        int resRow = this.executeUpdate(sql, fruit.getFname(), fruit.getPrice(), fruit.getFcount(), fruit.getRemark());
        // 打印受影响行数
        System.out.println("resRow = " + resRow);
    }

    @Override
    public void delFruit(Integer id) {

    }

    @Override
    public Fruit getFruit(Integer id) {
        return null;
    }

    @Override
    public Fruit getFruit(String name) {
        return null;
    }

    @Override
    public void updateFruit(Fruit fruit) {

    }
}

```

定义 JDBC配置文件：src/jdbc.properties

```properties
DRIVER=com.mysql.cj.jdbc.Driver
URL=jdbc:mysql://192.168.1.38:3306/javaweb?useSSL=false&serverTimezone=UTC&characterEncoding=utf8
USER=hanser
PWD=234234
```

测试类：test/TestFruit.java

```java
import com.fruit.dao.FruitDao;
import com.fruit.dao.impl.FruitDaoImpl;
import com.fruit.pojo.Fruit;
import org.junit.Test;

import java.math.BigDecimal;
import java.util.List;

public class TestFruit {
    // 创建fruitDao实例
    private FruitDao fruitDao = new FruitDaoImpl();

    @Test
    public void test01 (){
        BigDecimal bigDecimal = new BigDecimal("6.00");
        Fruit fruit = new Fruit(10,"黄桃",bigDecimal,60,"黄桃很好吃");
        fruitDao.addFruit(fruit);
    }

    @Test
    public void test02 (){
        List<Fruit> fruitList = fruitDao.getFruitList();
        for (Fruit fruit : fruitList) {
            System.out.println("fruit = " + fruit);
        }
    }
}
```

