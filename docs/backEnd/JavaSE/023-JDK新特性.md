# JDK8新特性

## 新增特性

新增什么特性

```java
在JDK8版本中 引入了很多新的内容 分为

新的语法
新的功能
新的底层实现
```

## 集合相关

```java
1、ArrayList 被设计为了懒加载的模式，
    即初始化无参构造，只维护一个空列表，当我们第一次添加元素，才将数组初始化为10。

2、HashMap加入了红黑树数据结构
```



## 接口相关

```java
1、接口中可以书写普通方法：使用default关键字修饰，加在返回值类型之前，访问修饰符之后。
    
2、接口中可以书写静态方法    
```

```java
package com.atguigu.test1;

public interface A {
    public default void m1(){

    }

    public static void m2(){
        
    }

}
```



## 函数式接口

> 函数式接口：即一个接口中只有一个抽象方法，这样的接口称之为SAM接口（Single Abstract Method ）；
>
> 这样的接口可以使用注解@FunctionalInterface修饰则称之为函数式接口；
>
> 函数式编程属于一种编程思想，就像面向过程，面向对象，等等都属于编程思想；
>
> 函数式编程的代表语言是Haskell，更强调函数(方法)可以实现什么操作，执行了什么功能，不注重是哪个角色调用了这个函数（方法），侧重于面向过程，不是面向对象（Java早期设计）；
>
> 使用函数式编程 即表示前提必须为函数式接口；

`只要一个接口中只有一个抽象方法，即可称之为函数式接口`

```java
package com.interfacePart.Test01;

public interface Usb {
    // 接口内 默认为 全局静态变量 即 public static final 修饰
    int A = 100;
    // 接口中的方法默认都为全局抽象方法 即不管是否书写均使用public abstract修饰
    void connect();
}
```



## lambda表达式

**lambda表达式的使用**

```java
package com.atguigu.test1;

/**
 *  回顾匿名内部类  ：即我们可以”直接new“接口 或者抽象类 相当于创建一个匿名内部类
 *  使用了lambda表达式以后 之前匿名内部类书写格式混乱的问题 可以得到解决
 *  前提：lambda表达式只能用于函数式接口
 *
 *  写法越简洁 前期越难理解 后期使用越方便
 */
public class B {
    public static void main(String[] args) {
        // 之前的写法，使用匿名内部类的方式
        C c1 = new C() {
            @Override
            public void m1() {
                System.out.println("匿名内部类的方式重写m1方法");
            }
        };
		// 调用执行
        c1.m1();

        // 无参 无返回值 只有一条语句
        C c2 = ()-> System.out.println("lambda表达式的方式重写m1方法");
		// 调用执行
        c2.m1();

        // 有一个参数 无返回值 只有一条语句，参数不用写类型声明，接口中已定义。
        D d1 = (a)-> System.out.println("lambda表达式方式重写D接口m1方法" + a);
        d1.m1(100);
        
        // 有两个个参数 无返回值 只有一条语句
        E e1 = (a,b)-> System.out.println("lambda表达式方式重写E接口m1方法" + a + b);
        e1.m1(123, "abc");

        // 有两个参数 有返回值 只有一条语句，不用写 return
        F f1 = (a,b)-> a + b;
        System.out.println(f1.m1(10, 20));

        // 有一个参数 有返回值 有多条语句，需要写一个大括号，有返回值，需要写return。
        F f2 = (a,b)->{
            System.out.println(a + b);
            return a + b;
        };

    }
}

interface F{
    int m1(int a,int b);
}
interface E{
    void m1(int a,String b);
}
interface D{
    void m1(int a);
}
interface C{
    void m1();
}
```

## 方法引用

以后使用Lambda表达式的形式，90%的场景是直接在方法体中直接调用一个方法，而不是在方法体中写逻辑，调用方法的技术也叫作方法引用。

✨ 方法引用的示例：

```java

```



## Stream流式编程

## Optional类