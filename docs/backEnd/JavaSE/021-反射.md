# 反射

## 基本概念

🚀 **作用**：在程序运行期间，动态的获取类对象，从而使用类对象获取类中相关的信息并且访问；

**通俗的讲**：不通过new对象的方式，依然可以访问类中的属性、方法、构造方法；

```java
生活中的反射：倒车镜，拍X光片，IDE的自动提示，
    在外部就可以得到内部的东西，类似于一个镜子，通过镜子能看到后边的内容。这就是反射。
万物皆对象 类、属性、方法、构造器 也属于对象。
```

🎨 反射类介绍

`java.lang.Class` 类类，每一个类都将在类加载阶段自动产生此类的实例；

`java.lang.reflect.Field` 字段/属性类，任何一个属性都属于此类的实例；

`java.lang.reflect.Method` 方法类，任何一个方法都属于此类的实例；

`java.lang.Constructor `构造器类，任何一个构造器都属于此类的实例；



## 获取Class对象

🚀 方式1：通过Class.forName 获取Class对象

```java
// 方式1：通过Class.forName 获取Class对象 ( String类型的 全限定名)
// 只能在运行时，获取到传入的参数，无法在编译时得知Class类对象的类型
Class<?> aClass = Class.forName("com.ReflectPart.Singer");
System.out.println("aClass = " + aClass); // class com.ReflectPart.Singer
```

🚀 方式2：使用类名.class属性 获取Class对象

```java
// 方式2：使用类名.class属性 获取Class对象
// 在编译时，就得知Class类对象的类型，所以可以提前得知Class类型的对象，泛型为Singer
Class<Singer> singerClass = Singer.class;
System.out.println("singerClass = " + singerClass); // class com.ReflectPart.Singer
```

🚀 方式3：使用Object类中getClass() 方法，获取Class对象（实例方法）

```java
// 方式3：使用Object类中getClass() 方法，获取Class对象（实例方法）
// 在编译时，可以得知Class类型的对象为Singer类或Singer类的子类，
Singer hanser = new Singer();
Class<? extends Singer> aClass1 = hanser.getClass();
System.out.println("aClass1 = " + aClass1); // class com.ReflectPart.Singer
```

## Class类

类本身也是一个类

**方法**

newInstance()

```java
作用：创建当前Class对象所对应泛型的实例（实例方法）
    
参数：无
    
返回值：实例对象
    
示例：
// 方式2：使用类名.class属性 获取Class对象
// 在编译时，就得知Class类对象的类型，所以可以提前得知Class类型的对象，泛型为Singer
Class<Singer> singerClass = Singer.class;
System.out.println("singerClass = " + singerClass); // class com.ReflectPart.Singer

// 返回一个 Singer (泛型)类型的实例
Singer singer = singerClass.newInstance()
```

getField(String fieldName)

```java
作用：根据字段名称获取到一个public修饰的字段对象
    
参数：String类型
    
返回值：Field类型
    
示例：
    
// 获取Class对象
Class<?> stuClass = Class.forName("com.yuluochenxiao.Student");
    
// 获取字段对象
Field field = stuClass.getField("age");
```

getFields()

```java
作用：获取本类中所有的public关键字修饰的字段
    
参数：无
    
返回值：Field类型的数组
    
示例：

// 获取Class对象
Class<?> stuClass = Class.forName("com.yuluochenxiao.Student");
    
// 获取字段对象
Field[] fields = stuClass.getFields();

// 遍历
fields.for
```

getDeclaredField(String name)

```java
作用：获取到指定的本类中已定义的字段(私有的也可以获取到)
    
参数：字段的String名称
    
返回值：Field类型
    
示例：

// 获取Class对象
Class<?> stuClass = Class.forName("com.yuluochenxiao.Student");
    
// 获取字段对象
Field field = stuClass.getDeclaredField("name");

```

getDeclaredFields() 

```java
作用：获取到本类中所有的已定义的字段
    
参数：无
    
返回值：Field类型数组
    
示例：

// 获取Class对象
Class<?> stuClass = Class.forName("com.yuluochenxiao.Student");
    
// 获取字段对象
Field[] fields = stuClass.getDeclaredFields();

// 遍历
fields.for
```



## Field类

类中的属性也有自己的类（类型定义，万物皆对象）

**方法**

getName()

```java
作用：获取字段的名称
    
参数：无
    
返回值：String
    
示例：

// 获取Class对象
Class<?> stuClass = Class.forName("com.yuluochenxiao.Student");
    
// 获取字段对象
Field field = stuClass.getField("age");

// 获取字段的名称
field.getName()
```

getType()

```java
作用：获取字段的类型
    
参数：无
    
返回值：String
    
示例：

// 获取Class对象
Class<?> stuClass = Class.forName("com.yuluochenxiao.Student");
    
// 获取字段对象
Field field = stuClass.getField("age");

// 获取字段的类型
field.getType() // 基本数据类型、数组、等
```

getModifiers()

```java
作用：获取字段的Java语言访问修饰符
    1 代表是public修饰的
    
参数：无
    
返回值：String
    
示例：

// 获取Class对象
Class<?> stuClass = Class.forName("com.yuluochenxiao.Student");
    
// 获取字段对象
Field field = stuClass.getField("age");

// 获取字段的类型
field.getType() // 基本数据类型、数组、等
```

set()

```java
作用：给属性赋值。
    
参数：第一个参数是哪一个学生对象，第二个参数是赋值
    
返回值：无
    
示例：
// 获取Class对象
Class<?> stuClass = Class.forName("com.yuluochenxiao.Student");
    
// 获取字段对象
Field field1 = stuClass.getField("age");
    
// 获取对象（方式1）
// Student stu = new Student();
Object o = stuClass.newInstance()

// 赋值（方式1）
// field1.set(stu,12);
field1.set(o,12);
```

get()

```java
作用：获取属性的值。
    
参数：第一个参数是哪一个对象
    
返回值：Field类型
    
示例：
// 获取Class对象
Class<?> stuClass = Class.forName("com.yuluochenxiao.Student");
    
// 获取字段对象
Field field1 = stuClass.getField("age");
    
// 获取对象
Object o = stuClass.newInstance()

// 获取属性值
field1.get(o);
```

setAccessible()

```java
作用：忽略JVM的安全检查。即可以在不在同类中访问私有属性
    （不通过反射是无法访问私有属性的，原因是在编译期间就无法通过）
    （反射是在运行时才用到的，绕过的编译的检查，但是在运行期间仍会抛异常，通过设置忽略风险，仍能够获取到私有属性）
    
参数：布尔值 true，忽略安全检查
    
返回值：无
    
示例：
// 获取Class对象
Class<?> stuClass = Class.forName("com.yuluochenxiao.Student");
    
// 获取字段对象
Field field1 = stuClass.getField("age");
    
// 忽略JVM的安全检查，访问私有属性
field1.setAccessible(true)
```



## 基本使用

> 反射可以在运行期间，动态的获取到类中的所有信息（属性，方法，实例，构造方法，静态方法等）。

✏️ 反射解决之前宠物系统中抽奖送宠物的问题。

```java
之前的实现方案：
根据用户传入对应的参数 来创建对象的宠物子类对象 返回；
    
弊端：
    这样编写有一个问题，因为是直接硬编码的方式创建对象。
    所以我们考虑到未来可能新增的类，即新的宠物子类，这样的书写方法，扩展性较差。
    
使用反射的方式解决：
    在编码期间并不直接写明具体创建哪个子类对象，而是根据调用者传入的全限定名来创建对象。
    这样更加灵活、扩展性更强、不会受限于硬编码的局限。     
```

📝 示例1：使用反射解决编译期间，无法确定未来新增的类。

（未使用反射）

```java
package com.ReflectPart.draw;
/**
 * 宠物类 父类
 */
public class Pet {
    protected String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Pet(String name) {
        this.name = name;
    }

    public Pet() {

    }

    public void print(){
        System.out.println("宠物的名字是：" + name);
    }
}

```

```java
package com.ReflectPart.draw;

public class Dog extends Pet{
    private String strain;
    public Dog() {}

    public Dog(String name, String strain) {
        super(name);
        this.strain = strain;
    }
}

```

```java
package com.ReflectPart.draw;

public class Penguin extends Pet{
    private char gender;

    public char getGender() {
        return gender;
    }

    public void setGender(char gender) {
        this.gender = gender;
    }

    public Penguin() {}

    public Penguin(String name, char gender) {
        super(name);
        this.gender = gender;
    }
}

```

```java
package com.ReflectPart.draw;

public class Master {
    // 抽奖获取宠物方法
    public Pet getPet(String str){
        // 如果不使用反射，这里还需要加很多判断，当获得3等奖之类的操作
        if (str.equals("No1")){
            Penguin penguin = new Penguin("小白",'雄');
            return penguin;
        } else if (str.equals("No2")){
            Dog dog = new Dog("大黄","金毛");
            return dog;
        }else {
            Dog dog = new Dog("小黄","金毛");
            return dog;
        }
    }
}

```

```java
package com.ReflectPart.draw;

public class Test {
    public static void main(String[] args) {
        Master mas = new Master();
        Pet pet = mas.getPet("No3");
        System.out.println("获得的奖品是 "+pet.name);
    }
}

```

### 获取对象

⚡️ 通过方式2：获取Class对象，然后再调用Object类中的`newInstance`方法，创建对象。

```java
之前的实现方案：
根据用户传入对应的参数 来创建对象的宠物子类对象 返回；
    
弊端：
    这样编写有一个问题，因为是直接硬编码的方式创建对象。
    所以我们考虑到未来可能新增的类，即新的宠物子类，这样的书写方法，扩展性较差。
    
使用反射的方式解决：
    在编码期间并不直接写明具体创建哪个子类对象，而是根据调用者传入的全限定名来创建对象。
    这样更加灵活、扩展性更强、不会受限于硬编码的局限。   
```

> 在编译期间无法确定具体的类名是什么，通过传入 包名+类名，全限定名的方式创建对象，更加灵活。
>
> 只有在使用的时候，才会把包名+类名传入给他，这就是反射做的事情，这也是框架做的事情。
>
> 用了框架以后只用写接口，写SQL语句，实现类是不用写的，他会帮我们自动生成。

```java
Spring框架：以后不会用new关键字了，通过反射和代理的技术结合到了一起。
```

```java
package com.ReflectPart.draw;

public class Master {
    // 抽奖获取宠物方法，参数是子类名称 包名+类名全限定名称
    public Pet getPet(String subClassName) {
        Pet pet = null;
        try {
            // 通过类类对象
            Class<?> aClass = Class.forName(subClassName);
            // 创建实例对象，默认使用的是无参构造方法创建
            Object obj = aClass.newInstance();
            // 判断类型，然后转换
            if (obj instanceof Pet){
                pet = (Pet) obj;
            }

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        // 把实例返回
        return pet;
    }
}

```

```java
package com.ReflectPart.draw;

public class Test {
    public static void main(String[] args) {
        // 创建mas对象
        Master mas = new Master();
        // 获取宠物对象
        Pet pet = mas.getPet("com.ReflectPart.draw.Dog");
        System.out.println("pet = " + pet); // pet = com.ReflectPart.draw.Dog@4554617c
    }
}
```

### 获取属性

> 优势：不需要知道类中的代码是怎么写的，可以提前写好，给类中的属性赋值。

```java
1. 先获取到Class对象
2. 再通过Class对象，调用对应方法，获取到字段
```

📝 使用示例：获取 `public` 修饰的属性

> 通过 Class类中的 getField方法获取，同时使用Field类中的set方法赋值。

```java
package com.ReflectPart;

public class Vup {
    public String name;
    int age;

    public Vup() {
    }

    public Vup(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

```java
package com.ReflectPart;

import java.lang.reflect.Field;

public class TestField1 {
    public static void main(String[] args) throws Exception {
        // 通过反射获取 类的Class对象
        Class<?> aClass = Class.forName("com.ReflectPart.Vup");
        // 获取所有的public修饰的字段对象
        Field[] fields = aClass.getFields();
        // 根据名称获取单个字段对象
        Field field1 = aClass.getField("name");
        // 遍历
        for (Field field : fields) {
            // 打印信息
            // name - class java.lang.String - 1
            System.out.println(field.getName() + " - " + field.getType() +  " - " + field.getModifiers());
        }
        String name = field1.getName();
        System.out.println("name = " + name); // name = name
        // 创建实例对象
        Object instance = aClass.newInstance();
        // 设置值
        field1.set(instance,"Hanser");
        // 读取值
        Object o = field1.get(instance);
        System.out.println("o = " + o); // o = Hanser
    }
}

```

📝 使用示例：获取 `private`、`protected` 修饰的属性

> 通过 Class类中的 getDeclaredField 方法获取，同时使用Field类中的set方法赋值。

```java
package com.ReflectPart;

public class Vup {
    public String name;
    int age;
    private int height;

    public Vup() {
    }

    public Vup(String name, int age, int height) {
        this.name = name;
        this.age = age;
        this.height = height;
    }
}

```

```java
package com.ReflectPart;

import java.lang.reflect.Field;

public class TestField1 {
    public static void main(String[] args) throws Exception {
        // 通过反射获取 类的Class对象
        Class<?> aClass = Class.forName("com.ReflectPart.Vup");
        // 获取所有的已定义的字段对象 返回值为字段数组
        Field[] declaredFields = aClass.getDeclaredFields();
        // 遍历属性数组
        for (Field declaredField : declaredFields) {
            System.out.println(declaredField.getName() + "-" + declaredField.getType() + "-" + declaredField.getModifiers());
        }
        // 根据名称获取到单个字段对象
        Field field1 = aClass.getDeclaredField("height");
        // 通过Vup类 Class对象 创建 up类实例
        Object obj = aClass.newInstance();
        // 表示忽略JVM的安全检查 即可以不在同类中访问私有属性
        field1.setAccessible(true);
        // 属性赋值
        // 第一个参数 表示给哪个对象的此属性赋值
        // 第二根参数 具体值
        field1.set(obj,12);

        // 获取属性值 参数表示获取哪个对象的此属性的值
        System.out.println(field1.get(obj));
    }
}

```



### 获取方法

```java

```



### 获取构造器

```java

```



### 获取注解

```java

```

